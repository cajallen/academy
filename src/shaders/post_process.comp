#version 450
#pragma shader_stage(compute)

#include "include.glsli"

// compositing
layout(binding = 0) uniform sampler2D s_color;
layout(binding = 1) uniform sampler2D s_emissive;
layout(binding = 2) uniform sampler2D s_normal;
layout(binding = 3) uniform sampler2D s_depth;
layout(binding = 4) uniform sampler2D s_widget;
layout(binding = 5) uniform sampler2D s_widget_depth;
layout(binding = 6) uniform sampler3D s_voxelization;
layout(binding = 7, rgba16f) uniform writeonly image2D u_target;

layout(constant_id = 0) const int target_width	= 0;
layout(constant_id = 1) const int target_height = 0;

layout (binding = 8) uniform CompositeData {
    mat4 inverse_vp;
    vec4 camera_position;
    
    mat4 light_vp;
    vec4 sun_data;
    vec4 ambient;
};

layout(push_constant) uniform uPushConstant {
	uint mode;
	float time;
} pc;

struct SimpleInputRead {
    vec3 position;
    vec3 normal;
    float depth;
};

struct InputRead {
    ivec2 coord;
    vec2 uv;
    vec3 position;
    vec3 color;
    vec3 emissive;
    vec3 normal;
    float roughness;
    float depth;
    float depth_read;
    vec4 widget_color;
    float widget_depth;
};

const int NUM_TAPS = 20;
const float TOTAL_TAPS_WEIGHT = 64.0;
const ivec3 samples[NUM_TAPS] = ivec3[](
    ivec3(-1, 0, 8),
    ivec3( 1, 0, 8),
    ivec3( 0,-1, 8),
    ivec3( 0, 1, 8),

    ivec3(-1,-1, 4),
    ivec3( 1, 1, 4),
    ivec3(-1, 1, 4),
    ivec3( 1,-1, 4),

    ivec3(-2, 0, 2),
    ivec3( 2, 0, 2),
    ivec3( 0,-2, 2),
    ivec3( 0, 2, 2),
    
    ivec3(-2, 1, 1),
    ivec3( 2, 1, 1),
    ivec3( 1,-2, 1),
    ivec3( 1, 2, 1),
    ivec3(-2,-1, 1),
    ivec3( 2,-1, 1),
    ivec3(-1,-2, 1),
    ivec3(-1, 2, 1)
);

SimpleInputRead read_simple_inputs(ivec2 coord) {
    SimpleInputRead data;
    data.normal = normalize(texelFetch(s_normal, coord, 0).rgb);
    float depth_read = texelFetch(s_depth, coord, 0).r;
    
    vec2 uv = vec2(coord) / vec2(target_width, target_height) * 2.0 - vec2(1.0);
    vec4 h_position_worldspace = inverse_vp * vec4(uv, depth_read, 1.0);
    data.position = h_position_worldspace.xyz / h_position_worldspace.w;

    if (depth_read == 0.0)
        data.depth = 1000.0;
    else
        data.depth = distance(camera_position.xyz, data.position);
    
    return data;
}

InputRead read_inputs(ivec2 coord) {
    InputRead data;
    data.coord = coord;
    data.color = texelFetch(s_color, coord, 0).rgb;
    data.emissive = texelFetch(s_emissive, coord, 0).rgb;
    data.normal = normalize(texelFetch(s_normal, coord, 0).rgb);
    data.roughness = texelFetch(s_normal, coord, 0).a;
    data.depth_read = max(texelFetch(s_depth, coord, 0).r, 0.0001);
    data.widget_color = texelFetch(s_widget, coord, 0);
    
    data.uv = vec2(coord) / vec2(target_width, target_height) * 2.0 - vec2(1.0);
    vec4 h_position_worldspace = inverse_vp * vec4(data.uv, data.depth_read, 1.0);
    data.position = h_position_worldspace.xyz / h_position_worldspace.w;
    if (data.depth_read == 0.0)
        data.depth = 1000.0;
    else
        data.depth = distance(camera_position.xyz, data.position);

    vec4 widget_hpos = inverse_vp * vec4(data.uv, texelFetch(s_widget_depth, coord, 0).r, 1.0);
    vec3 widget_position = widget_hpos.xyz / widget_hpos.w;
    data.widget_depth = distance(camera_position.xyz, widget_position);
    return data;
}

float max(vec2 v) {
    return max(v.x, v.y);
}

vec3 calculate_lighting(InputRead data, float amb_factor, float diff_factor) {
    vec3 to_light = normalize(sun_data.xyz);
    vec3 view_dir = normalize(data.position - camera_position.xyz);
    vec3 reflection_dir = reflect(to_light, data.normal);
    float NdotL = dot(data.normal, to_light);
    float VdotR = dot(view_dir, reflection_dir);
    float VdotN = dot(view_dir, data.normal);

    float smoothness = clamp(1.0 - data.roughness, 0.001, 1.0);

    vec3 ambient = data.color * ambient.rgb * ambient.a * amb_factor;
    vec3 diffuse = data.color * clamp(NdotL, 0.0, 1.0) * diff_factor;
    vec3 specular = vec3(0.0);

    return (diffuse + specular) + ambient + data.emissive;
}

vec3 fog(vec3 color, float depth) {
    float x = 1.0 - exp(-(depth-4.0) / 300.0);
    return mix(color, vec3(0.4, 0.5, 0.6), x);
}

vec3 trace_voxelization(InputRead data) {
    vec4 origin_hpos = inverse_vp * vec4(data.uv.x, data.uv.y, 0.9999f, 1.0f);
    vec4 end_hpos    = inverse_vp * vec4(data.uv.x, data.uv.y, 0.0001f, 1.0f);

    vec3 origin      = origin_hpos.xyz / origin_hpos.w;
    vec3 dir         = normalize(end_hpos.xyz / end_hpos.w - origin);

    return texture(s_voxelization, origin + dir).rgb;
}

layout (local_size_x = 8, local_size_y = 8) in;
void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	
	InputRead data = read_inputs(coord);
	
    vec3 color = calculate_lighting(data, 1.0, 1.0);
    
    if (data.widget_color.a > 0.0) {
        if (data.widget_depth < data.depth)
            color = mix(color, data.widget_color.rgb, data.widget_color.a);
        else {
            if ((coord.x % 2 == 0) && (coord.y % 2 == 0))
                color = mix(color, data.widget_color.rgb, 0.5 * data.widget_color.a);
        }
    }
    
    color = fog(color, data.depth);
    
    switch (pc.mode) {
        case 0:
            imageStore(u_target, coord, vec4(linear_to_srgb(color.rgb), 1.0));
            break;
        case 1:
            imageStore(u_target, coord, vec4(linear_to_srgb(data.color.rgb), 1.0));
            break;
        case 2:
            imageStore(u_target, coord, vec4(linear_to_srgb(data.emissive.rgb), 1.0));
            break;
        case 3:
            imageStore(u_target, coord, vec4(linear_to_srgb(data.position), 1.0));
            break;
        case 4:
            imageStore(u_target, coord, vec4(linear_to_srgb(data.normal), 1.0));
            break;
        case 5:
            imageStore(u_target, coord, vec4(trace_voxelization(data), 1.0));
            break;
    }
}